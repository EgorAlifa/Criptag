<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculator Tasks</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');
        .page-title {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1rem;
        position: relative;
    }

    .calculator-hint {
        position: fixed;
        right: 20px;
        bottom: 20px;
        background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
        color: white;
        padding: 0.75rem 1.25rem;
        border-radius: 50px;
        font-size: 0.875rem;
        box-shadow: 0 4px 12px rgba(79, 70, 229, 0.2);
        transition: all 0.3s ease;
        z-index: 1000;
        white-space: nowrap;
        text-decoration: none;
        display: block;
    }

    .calculator-hint:hover {
        transform: translateX(-5px);
        box-shadow: 0 6px 16px rgba(79, 70, 229, 0.3);
    }

    @media (max-width: 768px) {
        .calculator-hint {
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
        }
    }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background: linear-gradient(135deg, #e0e7ff 0%, #c7d2fe 100%);
            padding: 2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .page-title {
            color: #1e1b4b;
            font-size: 2rem;
            text-align: center;
            margin-bottom: 2rem;
            font-weight: 600;
        }

        .tasks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .task-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 2rem;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(99, 102, 241, 0.1);
        }

        .task-header {
            color: #1e1b4b;
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid rgba(99, 102, 241, 0.2);
        }

        .task-content {
            min-height: 200px;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #4b5563;
            font-weight: 500;
        }

        .calculator input {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.2s;
            background: white;
            margin-bottom: 1rem;
        }

        .calculator input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .calculator button {
            width: 100%;
            padding: 0.875rem;
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .calculator button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.2);
        }

        .calculator .error {
            color: #dc2626;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            text-align: center;
        }

        .solution-steps {
            margin-top: 1.5rem;
            padding: 1rem;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            white-space: pre-wrap;
            font-family: monospace;
            line-height: 1.5;
        }
        .solution-steps1 {
            padding: 1rem;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
            white-space: normal;
            font-family: monospace;
            line-height: 1.5;
        }
        .input-row {
            gap: 1rem;
        }

        .select-input {
            padding: 0.5rem;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 0.875rem;
        }

        .label-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        /* Ensure inputs and labels are properly aligned */
        .input-row label {
            margin-bottom: 0.5rem;
            display: block;
        }

        .input-row input,
        .input-row select {
            height: 2.25rem; /* Ensure consistent height */
            box-sizing: border-box;
        }

        .placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 200px;
            background: rgba(99, 102, 241, 0.1);
            border-radius: 8px;
            color: #6366f1;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }

            .tasks-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="page-title">Calculator Tasks</h1>
        <a href="test.html" class="calculator-hint">Калькулятор mod</a>
        
        <div class="tasks-grid">
            <!-- Task 1: Modulus Calculator -->
            <div class="task-card">
                <h2 class="task-header">Task 1: Mod криптографии </h2>
                <div class="task-content calculator">
                    <div class="input-group">
                        <label>Введите исходное y формата (2^x mod 19)</label>
                        <input type="text" id="expression" placeholder="Например: 2^x mod 19">
                    </div>
                    <div class="input-group">
                        <label>Xa значение</label>
                        <input type="number" id="xa" placeholder="Например: 4">
                    </div>
                    <div class="input-group">
                        <label>Xb значение</label>
                        <input type="number" id="xb" placeholder="Например: 9">
                    </div>
                    <button onclick="calculateWithSteps()">Calculate</button>
                    <div id="error" class="error"></div>
                    <div id="solution-steps" class="solution-steps"></div>
                </div>
            </div>

            <!-- Task 2 Placeholder -->
           <div class="task-card">
                <h2 class="task-header">Task 2: RSA Key Generation</h2>
                <div class="task-content calculator">
                    <div class="input-grid">
                        <div class="input-group">
                            <label>Введите p</label>
                            <input type="number" id="p-value" placeholder="Например: 3" class="small-input">
                        </div>
                        <div class="input-group">
                            <label>Введите q</label>
                            <input type="number" id="q-value" placeholder="Например: 11" class="small-input">
                        </div>
                    </div>
                    <div class="input-group">
                        <label>Введите m (через запятую)</label>
                        <input type="text" id="m-value" placeholder="Например: 5,5,4" class="small-input">
                    </div>
                    <button onclick="calculateRSA()">Calculate</button>
                    <div id="rsa-error" class="error"></div>
                    <div id="rsa-solution" class="solution-steps"></div>
                </div>
            </div>

            <!-- Task 3 Placeholder -->
            <div class="task-card">
                <h2 class="task-header">Task 3: Решение задачи о ранце кодирования степеней 2 (старшие разряды 4 и 5 значных чисел, для трех чисел только младшие разряды)</h2>
                <div class="task-content calculator">
                    <div class="input-row">
                        <div class="label-group">
                            <label>Выберите индекс</label>
                            <select id="a-index" class="select-input">
                                <option value="0">a₀</option>
                                <option value="1">a₁</option>
                                <option value="2">a₂</option>
                                <option value="3">a₃</option>
                                <option value="4">a₄</option>
                            </select>
                        </div>
                        <div class="label-group">
                            <label>Введите значение</label>
                            <input type="number" id="a-value" placeholder="Например: 90106" class="small-input">
                        </div>
                    </div>
                    <div class="label-group">
                        <label>Резервное сообщение M (5 бит):</label>
                        <input type="text" id="backup-m" placeholder="Введите 5-битное сообщение (например, 10001)" class="small-input">
                    </div>
                    <button onclick="calculateKnapsack()">Calculate</button>
                    <div id="knapsack-error" class="error"></div>
                    <div id="knapsack-solution" class="solution-steps"></div>
                </div>
            </div>
            <!-- Task 3.1 Placeholder -->
            <div class="task-card">
                <h2 class="task-header">Task 3.1: Решение задачи о ранце кодирования степеней 2 (младшие разряды 4 и 5 значных чисел, для трех чисел только старшие разряды)</h2>
                <div class="task-content calculator">
                    <div class="input-row">
                        <div class="label-group">
                            <label>Выберите индекс</label>
                            <select id="a-index-junior" class="select-input">
                                <option value="0">a₀</option>
                                <option value="1">a₁</option>
                                <option value="2">a₂</option>
                                <option value="3">a₃</option>
                                <option value="4">a₄</option>
                            </select>
                        </div>
                        <div class="label-group">
                            <label>Введите значение</label>
                            <input type="number" id="a-value-junior" placeholder="Например: 90106" class="small-input">
                        </div>
                    </div>
                    <div class="label-group">
                        <label>Резервное сообщение M (5 бит):</label>
                        <input type="text" id="backup-m-junior" placeholder="Введите 5-битное сообщение (например, 10001)" class="small-input">
                    </div>
                    <button onclick="calculateKnapsackJunior()">Calculate</button>
                    <div id="knapsack-error-junior" class="error"></div>
                    <div id="knapsack-solution-junior" class="solution-steps"></div>
                </div>
            </div>
            <!-- Task 4 Placeholder -->
            <div class="task-card">
                <h2 class="task-header">Task 4: Решение задачи о ранце кодирования степеней 5 (старшие разряды 4 и 5 значных чисел, для трех чисел только младшие разряды)</h2>
                <div class="task-content calculator">
                    <div class="input-row">
                        <div class="label-group">
                            <label>Выберите индекс</label>
                            <select id="a-index-5" class="select-input">
                                <option value="0">a₀</option>
                                <option value="1">a₁</option>
                                <option value="2">a₂</option>
                                <option value="3">a₃</option>
                                <option value="4">a₄</option>
                            </select>
                        </div>
                        <div class="label-group">
                            <label>Введите значение</label>
                            <input type="number" id="a-value-5" placeholder="Например: 90106" class="small-input">
                        </div>
                    </div>
                    <div class="label-group">
                        <label>Резервное сообщение M (5 бит):</label>
                        <input type="text" id="backup-m-5" placeholder="Введите 5-битное сообщение (например, 10001)" class="small-input">
                    </div>
                    <button onclick="calculateKnapsackFor5()">Calculate</button>
                    <div id="knapsack-error-5" class="error"></div>
                    <div id="knapsack-solution-5" class="solution-steps"></div>
                </div>
            </div>
            <!-- Task 4.1 - Modified version for lower digits -->
            <div class="task-card">
                <h2 class="task-header">Task 4.1: Решение задачи о ранце кодирования степеней 5 (младшие разряды 4 и 5 значных чисел, для трех чисел старшие разряды)</h2>
                <div class="task-content calculator">
                    <div class="input-row">
                        <div class="label-group">
                            <label>Выберите индекс</label>
                            <select id="a-index-5-mod" class="select-input">
                                <option value="0">a₀</option>
                                <option value="1">a₁</option>
                                <option value="2">a₂</option>
                                <option value="3">a₃</option>
                                <option value="4">a₄</option>
                            </select>
                        </div>
                        <div class="label-group">
                            <label>Введите значение</label>
                            <input type="number" id="a-value-5-mod" placeholder="Например: 90106" class="small-input">
                        </div>
                    </div>
                    <div class="label-group">
                        <label>Резервное сообщение M (5 бит):</label>
                        <input type="text" id="backup-m-5-mod" placeholder="Введите 5-битное сообщение (например, 10001)" class="small-input">
                    </div>
                    <button onclick="calculateKnapsackFor5Modified()">Calculate Modified Version</button>
                    <div id="knapsack-error-5-mod" class="error"></div>
                    <div id="knapsack-solution-5-mod" class="solution-steps"></div>
                </div>
            </div>
            <!-- Task 5: Lower digits for powers of 3 -->
            <div class="task-card">
                <h2 class="task-header">Task 5: Решение задачи о ранце кодирования степеней 3 (младшие разряды)</h2>
                <div class="task-content calculator">
                    <div class="input-row">
                        <div class="label-group">
                            <label>Выберите индекс</label>
                            <select id="a-index-3-lower" class="select-input">
                                <option value="0">a₀</option>
                                <option value="1">a₁</option>
                                <option value="2">a₂</option>
                                <option value="3">a₃</option>
                                <option value="4">a₄</option>
                            </select>
                        </div>
                        <div class="label-group">
                            <label>Введите значение</label>
                            <input type="number" id="a-value-3-lower" placeholder="Например: 90106" class="small-input">
                        </div>
                    </div>
                    <div class="label-group">
                        <label>Резервное сообщение M (5 бит):</label>
                        <input type="text" id="backup-m-3-lower" placeholder="Введите 5-битное сообщение (например, 10001)" class="small-input">
                    </div>
                    <button onclick="calculateKnapsackFor3Lower()">Calculate</button>
                    <div id="knapsack-error-3-lower" class="error"></div>
                    <div id="knapsack-solution-3-lower" class="solution-steps"></div>
                </div>
            </div>

            <!-- Task 5.1: Upper digits for powers of 3 -->
            <div class="task-card">
                <h2 class="task-header">Task 5.1: Решение задачи о ранце кодирования степеней 3 (старшие разряды)</h2>
                <div class="task-content calculator">
                    <div class="input-row">
                        <div class="label-group">
                            <label>Выберите индекс</label>
                            <select id="a-index-3-upper" class="select-input">
                                <option value="0">a₀</option>
                                <option value="1">a₁</option>
                                <option value="2">a₂</option>
                                <option value="3">a₃</option>
                                <option value="4">a₄</option>
                            </select>
                        </div>
                        <div class="label-group">
                            <label>Введите значение</label>
                            <input type="number" id="a-value-3-upper" placeholder="Например: 90106" class="small-input">
                        </div>
                    </div>
                    <div class="label-group">
                        <label>Резервное сообщение M (5 бит):</label>
                        <input type="text" id="backup-m-3-upper" placeholder="Введите 5-битное сообщение (например, 10001)" class="small-input">
                    </div>
                    <button onclick="calculateKnapsackFor3Upper()">Calculate</button>
                    <div id="knapsack-error-3-upper" class="error"></div>
                    <div id="knapsack-solution-3-upper" class="solution-steps"></div>
                </div>
            </div>
            <!-- Task 6 Placeholder -->
            <div class="task-card">
                <h2 class="task-header">Task 6: Многопользовательская криптосистема RSA</h2>
                <div class="task-content calculator">
                    <button id="rsa-generate-btn" onclick="generateRSAExample()">Generate Example</button>
                    <!-- Уникальный контейнер для результата -->
                    <div id="rsa-result" class="solution-steps1"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
function modularExponentiation(base, exp, mod, showSteps = false) {
    let result = 1;
    let steps = '';
    let tempResults = { 0: 1 }; // Сохраняем 2^0 = 1

    if (showSteps) {
        steps = `${base}^${exp} mod ${mod} = `;
        
        // Разложение степени на сумму степеней двойки
        let binaryExp = exp.toString(2);
        let powers = [];
        for (let i = 0; i < binaryExp.length; i++) {
            if (binaryExp[i] === '1') {
                powers.push(binaryExp.length - 1 - i);
            }
        }

        // Вычисляем промежуточные значения
        let currentValue = base;
        for (let i = 0; i <= Math.max(...powers); i++) {
            tempResults[i] = currentValue;
            currentValue = (currentValue * currentValue) % mod;
        }

        // Собираем строку разложения и произведения
        let decomposition = powers.map(p => `${base}^${Math.pow(2, p)}`).join(' · ');
        steps += decomposition + ` mod ${mod} = `;
        
        let products = [];
        result = 1;
        for (let power of powers) {
            result = (result * tempResults[power]) % mod;
            products.push(tempResults[power]);
        }

        steps += products.join(' · ') + ` mod ${mod} = ${result}`;
    } else {
        while (exp > 0) {
            if (exp % 2 === 1) {
                result = (result * base) % mod;
            }
            exp = Math.floor(exp / 2);
            base = (base * base) % mod;
        }
    }

    return { result, steps };
}

function calculateWithSteps() {
    const expressionInput = document.getElementById('expression');
    const xaInput = document.getElementById('xa');
    const xbInput = document.getElementById('xb');
    const solutionSteps = document.getElementById('solution-steps');
    const errorDiv = document.getElementById('error');
    
    try {
        const expression = expressionInput.value;
        const xa = parseInt(xaInput.value);
        const xb = parseInt(xbInput.value);
        
        const matches = expression.match(/(\d+)\^x\s*mod\s*(\d+)/);
        if (!matches) {
            throw new Error('Invalid expression format');
        }

        const base = parseInt(matches[1]);
        const mod = parseInt(matches[2]);

        if (isNaN(xa) || isNaN(xb)) {
            throw new Error('Please enter valid XA and XB values');
        }

        let steps = `Задание №1\n`;
        steps += `1) y = ${base}^x mod ${mod}\n`;
        steps += `   XA = ${xa}, XB = ${xb}\n\n`;

        const yACalc = modularExponentiation(base, xa, mod, true);
        steps += `2) A: yA = ${yACalc.steps}\n\n`;

        const yBCalc = modularExponentiation(base, xb, mod, true);
        steps += `B: yB = ${yBCalc.steps}\n\n`;

        steps += `3) A: yA → B\n`;
        steps += `   B: yB → A\n\n`;

        const kABCalcA = modularExponentiation(yBCalc.result, xa, mod, true);
        steps += `4)A: Kab: ${kABCalcA.steps}\n`;

        const kABCalcB = modularExponentiation(yACalc.result, xb, mod, true);
        steps += `B: Kba: ${kABCalcB.steps}\n\n`;

        steps += `Kab=Kba = ${kABCalcA.result} - Общий секретный ключ`;

        solutionSteps.textContent = steps;
        solutionSteps.style.display = 'block';
        errorDiv.textContent = '';
        
    } catch (err) {
        errorDiv.textContent = err.message || 'Please check your input format';
        solutionSteps.style.display = 'none';
    }
}

document.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        calculateWithSteps();
    }
});


 // Номер 2 начинается тут
 function extendedGCD(a, b) {
    if (b === 0) {
        return [a, 1, 0];
    }

    const [gcd, x1, y1] = extendedGCD(b, a % b);
    const x = y1;
    const y = x1 - Math.floor(a / b) * y1;

    return [gcd, x, y];
}

function findSmallestD(phiN) {
    let e = 3;
    let smallestD = Infinity;
    let finalE = null;
    let selectionSteps = `Процесс выбора e и d:\n\n`;

    while (e < Math.min(100, phiN)) {
        if (gcd(e, phiN) === 1) {
            const [g, x, y] = extendedGCD(e, phiN);
            let d = (x % phiN + phiN) % phiN;

            if (d < smallestD) {
                smallestD = d;
                finalE = e;
                selectionSteps += `e = ${e}: gcd(${e}, ${phiN}) = 1, d = ${d}\n`;
                selectionSteps += `Ищем найменьшую d\n`;
            }
        }
        e = nextPrime(e);
    }

    selectionSteps += `\nИтоговый выбор: e = ${finalE}, d = ${smallestD}\n`;
    return [finalE, smallestD, selectionSteps];
}


function gcd(a, b) {
    while (b !== 0) {
        let t = b;
        b = a % b;
        a = t;
    }
    return a;
}

function isPrime(num) {
    if (num <= 1) return false;
    if (num <= 3) return true;
    if (num % 2 === 0 || num % 3 === 0) return false;

    for (let i = 5; i * i <= num; i += 6) {
        if (num % i === 0 || num % (i + 2) === 0) return false;
    }
    return true;
}

function nextPrime(n) {
    let next = n + 1;
    while (!isPrime(next)) {
        next++;
    }
    return next;
}

function modularExponentiationWithSteps(base, exp, mod) {
    let result = 1;
    let steps = `${base}^${exp} mod ${mod} = `;

    let currentValue = base;
    let tempResults = { 0: 1 };
    let powers = [];

    for (let i = 0; exp > 0; i++) {
        if (exp % 2 === 1) {
            powers.push(i);
        }
        tempResults[i] = currentValue;
        currentValue = (currentValue * currentValue) % mod;
        exp = Math.floor(exp / 2);
    }

    let decomposition = powers.map(p => `${base}^${Math.pow(2, p)}`).join(' · ');
    steps += decomposition + ` mod ${mod} = `;

    result = powers.reduce((acc, p) => (acc * tempResults[p]) % mod, 1);
    let products = powers.map(p => tempResults[p]).join(' · ');

    steps += products + ` mod ${mod} = ${result}`;
    return { result, steps };
}

function calculateRSA() {
    const pValue = parseInt(document.getElementById('p-value').value);
    const qValue = parseInt(document.getElementById('q-value').value);
    const mValue = document.getElementById('m-value').value;
    const solution = document.getElementById('rsa-solution');
    const error = document.getElementById('rsa-error');

    try {
        if (!pValue || !qValue || !mValue) {
            throw new Error('Пожалуйста, заполните все поля');
        }

        const mArray = mValue.split(',').map(x => parseInt(x.trim()));
        let steps = `Task 2\n`;
        steps += `14) p = ${pValue}, q = ${qValue}, m = ${mArray.join(',')}\n\n`;

        const N = pValue * qValue;
        const phiN = (pValue - 1) * (qValue - 1);
        steps += `a) Формируем PK_A и SK_A\n`;
        steps += `N = p·q = ${N}\n`;
        steps += `φ(N) = (p-1)(q-1) = ${phiN}\n\n`;

        const [e, d, selectionSteps] = findSmallestD(phiN);
        steps += selectionSteps + '\n';
        steps += `PK_A = {${e}, ${N}} - Публичный ключ\n`;
        steps += `SK_A = ${d} - Секретный ключ\n\n`;

        const hm = mArray.reduce((a, b) => a + b, 0) % 8;
        steps += `б) A: формирует эл. подпись\n`;
        steps += `m = ${mArray.join(',')} => h(m) = Σ(${mArray.join('+')}) mod 8 = ${hm}\n`;

        const signCalc = modularExponentiationWithSteps(hm, d, N);
        steps += `SignA(m) = (h(m))^d mod N\n`;
        steps += `SignA(m) = ${signCalc.steps}\n\n`;

        steps += `Получается, что отправляем:\n`;
        steps += `(${mArray.join(',')}; ${signCalc.result}) → B\n\n`;

        steps += `в) Проверка подписи:\n`;
        steps += `   а) h(m') = ${hm}\n`;

        const verifyCalc = modularExponentiationWithSteps(signCalc.result, e, N);
        steps += `   б) (signA)^e mod N = ${verifyCalc.steps}\n\n`;

        if (verifyCalc.result === hm) {
            steps += `Так как h(m') = h(m) = ${hm} =>\n`;
            steps += `документ подлинный`;
        } else {
            steps += `Подпись недействительна`;
        }

        solution.textContent = steps;
        solution.style.display = 'block';
        error.textContent = '';
    } catch (err) {
        error.textContent = err.message;
        solution.style.display = 'none';
    }
}

document.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        calculateRSA();
    }
});

 // Номер 3 начинается тут

 function calculateKnapsack() {
    const selectedIndex = parseInt(document.getElementById('a-index').value);
    const inputValue = document.getElementById('a-value').value;
    const backupM = document.getElementById('backup-m').value.trim(); // Получаем резервное сообщение M
    const solution = document.getElementById('knapsack-solution');
    const error = document.getElementById('knapsack-error');

    try {
        if (isNaN(parseInt(inputValue))) {
            throw new Error('Пожалуйста, введите значение a');
        }

        if (inputValue.length < 3 || inputValue.length > 5) {
            throw new Error('Число должно быть длиной 3, 4 или 5 цифр');
        }

        const isFiveDigit = inputValue.length === 5;
        const isFourDigit = inputValue.length === 4;
        const isThreeDigit = inputValue.length === 3;

        // Извлекаем степенную часть в зависимости от длины числа
        let powerPart;
        if (isThreeDigit) {
            powerPart = parseInt(inputValue.substring(1)); // Берем последние 2 цифры
        } else if (isFourDigit) {
            powerPart = parseInt(inputValue.substring(0, 2));
        } else { // Для пятизначных
            powerPart = parseInt(inputValue.substring(1, 3));
        }

        const values = new Array(5);
        values[selectedIndex] = inputValue;

        // Заполняем значения до выбранного индекса (уменьшаем степень двойки)
        let currentPowerPart = powerPart;
        for (let i = selectedIndex - 1; i >= 0; i--) {
            currentPowerPart = Math.max(1, Math.floor(currentPowerPart / 2));
            if (isThreeDigit) {
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                values[i] = `${randomFirstDigit}${currentPowerPart.toString().padStart(2, '0')}`;
            } else if (isFourDigit) {
                const randomPart = Math.floor(1 + Math.random() * 99).toString().padStart(2, '0');
                values[i] = `${currentPowerPart.toString().padStart(2, '0')}${randomPart}`;
            } else {
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                const randomPart = Math.floor(1 + Math.random() * 99).toString().padStart(2, '0');
                values[i] = `${randomFirstDigit}${currentPowerPart.toString().padStart(2, '0')}${randomPart}`;
            }
        }

        // Заполняем значения после выбранного индекса (увеличиваем степень двойки)
        currentPowerPart = powerPart;
        for (let i = selectedIndex + 1; i < 5; i++) {
            currentPowerPart = Math.min(64, currentPowerPart * 2);
            if (isThreeDigit) {
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                values[i] = `${randomFirstDigit}${currentPowerPart.toString().padStart(2, '0')}`;
            } else if (isFourDigit) {
                const randomPart = Math.floor(1 + Math.random() * 99).toString().padStart(2, '0');
                values[i] = `${currentPowerPart.toString().padStart(2, '0')}${randomPart}`;
            } else {
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                const randomPart = Math.floor(1 + Math.random() * 99).toString().padStart(2, '0');
                values[i] = `${randomFirstDigit}${currentPowerPart.toString().padStart(2, '0')}${randomPart}`;
            }
        }
        const numericValues = values.map(v => parseInt(v, 10)); // Преобразуем в массив чисел
        const sum = numericValues.reduce((a, b) => a + b, 0); // Суммируем числа
        let T = sum + 1;
        function factorize(n) {
        let factors = [];
        // Ищем простые делители числа n
        for (let i = 2; i <= Math.sqrt(n); i++) {
            while (n % i === 0) {
                factors.push(i); // Добавляем делитель в массив
                n /= i; // Делим на этот делитель
            }
        }
        // Если остался простое число больше 1
        if (n > 1) {
            factors.push(n);
        }
        return factors;
    }
    
        // Разложение T + 1 на два простых числа
        const [prime1, prime2] = factorize(T);
        if (!prime1 || !prime2) {
            throw new Error('Невозможно разложить T + 1 на два простых числа. P.S Нажимай на кнопку до тех пор, пока не выйдет решение.');
        }

        // Используем найденные простые числа для R и S
        let R = prime1;
        let S = prime2;

        // Если R >= S, меняем их местами
        if (R >= S) {
            [R, S] = [S, R];
        }
        R = findDynamicR(T); // Пересчитываем R, если нужно

        // Функция для нахождения наибольшего общего делителя
        function gcd(a, b) {
            while (b) {
                [a, b] = [b, a % b];
            }
            return a;
        }
        // Функция для нахождения R, которое взаимно простое с T
        function findDynamicR(T) {
            let R = 2; // Начинаем с первого возможного R
            while (gcd(R, T) !== 1) {  // Пока НОД не равен 1
                R++;
            }
            return R;
        }

        // Расширенный алгоритм Евклида для нахождения обратного элемента
        function extendedEuclidean(a, b) {
            if (b === 0) {
                return [1, 0, a];
            }
            const [x1, y1, gcd] = extendedEuclidean(b, a % b);
            const x = y1;
            const y = x1 - Math.floor(a / b) * y1;
            return [x, y, gcd];
        }

        // Находим мультипликативную инверсию для S
        const [S_inv, , gcdResult] = extendedEuclidean(R, T);
        if (gcdResult !== 1) {
            throw new Error('Невозможно найти мультипликативную инверсию');
        }

        // Корректируем значение S_inv
        const adjustedS = (S_inv % T + T) % T; // Модифицируем S_inv для положительного значения

        // Массив bValues, вычисленный с использованием R и T
        const bValues = numericValues.map(a => (a * R) % T);
        let steps = `Сгенерированные значения a:\n`;
        values.forEach((a, i) => {
            steps += `a${i} = ${a}${i === selectedIndex ? ' (введено)' : ''}\n`;
        });
        steps += `\n1) Найдём R, S, T:\n`;
        steps += `Σai = ${numericValues.join(' + ')} = ${sum}\n`;
        steps += `Пусть T = ${T} > Σai = ${sum}\n`;
        steps += `Пусть R = ${R} < T = ${T}\n`;
        steps += `Найдём S: RS (mod T)=1\n`;
        steps += `S = ${adjustedS}\n\n`;

        steps += `2) Составим вектор b = a·R mod T:\n`;
        bValues.forEach((b, i) => {
            steps += `b${i} = ${numericValues[i]}·${R} mod ${T} = ${b}\n`;
        });
        steps += `\nSecret key = (S = ${adjustedS}, T = ${T})\n`;
        steps += `Public key = b\n`;

        steps += `\n3) Зашифруем сообщение M:\n`;

        let M = '';
        for (let i = 0; i < 5; i++) {
            M += Math.round(Math.random());
        }

        let C2 = 0;
        for (let i = 0; i < 5; i++) {
            if (M[i] === '1') {
                C2 += bValues[i];
            }
        }

        steps += `M = ${M.split('').reverse().join('')}\n`;
        steps += `C_2 = `;
        let firstTerm = true;
        for (let i = 0; i < 5; i++) {
            if (M[i] === '1') {
                if (!firstTerm) steps += ' + ';
                steps += `${bValues[i]}`;
                firstTerm = false;
            }
        }
        steps += ` = ${C2}\n`;

        steps += `\n4) Расшифровка: Проверяем восстановление M с C_2 и S\n`;

        let sum_ai = BigInt(C2) * BigInt(adjustedS) % BigInt(T);
        steps += `C_2·S (mod T) = ${C2}·${adjustedS} mod ${T} = ${sum_ai}\n`;

        let recovered_M = '';
        for (let i = 4; i >= 0; i--) {
            if (sum_ai >= BigInt(numericValues[i])) {
                recovered_M = '1' + recovered_M;
                sum_ai -= BigInt(numericValues[i]);
                steps += `Вычитаем a${i} = ${numericValues[i]}, остаток = ${sum_ai}\n`;
            } else {
                recovered_M = '0' + recovered_M;
                steps += `a${i} = ${numericValues[i]} не вычитается, остаток = ${sum_ai}\n`;
            }
        }

        steps += `Восстановленное M = ${recovered_M.split('').reverse().join('')}\n`;

        if (recovered_M === M) {
            steps += `Дешифрование прошло успешно!\n`;
        } else {
            if (backupM.length === 5 && /^[01]{5}$/.test(backupM)) {
                M = backupM; // Используем введенное резервное сообщение
            } else {
                M = '10001'; // Используем заведомо работающий вариант
            }

            C2 = 0;
            for (let i = 0; i < 5; i++) {
                if (M[i] === '1') {
                    C2 += bValues[i];
                }
            }

            steps += `Попробуем другое сообщение M = ${M}\n`;
            steps += `C_2 = `;
            firstTerm = true;
            for (let i = 0; i < 5; i++) {
                if (M[i] === '1') {
                    if (!firstTerm) steps += ' + ';
                    steps += `${bValues[i]}`;
                    firstTerm = false;
                }
            }
            steps += ` = ${C2}\n`;

            let newSum_ai = BigInt(C2) * BigInt(adjustedS) % BigInt(T);
            steps += `C_2·S (mod T) = ${C2}·${adjustedS} mod ${T} = ${newSum_ai}\n`;

            sum_ai = newSum_ai;
            recovered_M = '';
            for (let i = 4; i >= 0; i--) {
                if (sum_ai >= BigInt(numericValues[i])) {
                    recovered_M = '1' + recovered_M;
                    sum_ai -= BigInt(numericValues[i]);
                } else {
                    recovered_M = '0' + recovered_M;
                }
            }

            steps += `Восстановленное M = ${recovered_M}\n`;
        }

        solution.textContent = steps;
        solution.style.display = 'block';
        error.textContent = '';
    } catch (err) {
        error.textContent = err.message;
        solution.style.display = 'none';
    }
}
// Номер 3.1 начинается тут 
function calculateKnapsackJunior() {
    const selectedIndex = parseInt(document.getElementById('a-index-junior').value);
    const inputValue = document.getElementById('a-value-junior').value;
    const backupM = document.getElementById('backup-m-junior').value.trim();
    const solution = document.getElementById('knapsack-solution-junior');
    const error = document.getElementById('knapsack-error-junior');

    try {
        if (isNaN(parseInt(inputValue))) {
            throw new Error('Пожалуйста, введите значение a');
        }

        if (inputValue.length < 3 || inputValue.length > 5) {
            throw new Error('Число должно быть длиной 3, 4 или 5 цифр');
        }

        const isFiveDigit = inputValue.length === 5;
        const isFourDigit = inputValue.length === 4;
        const isThreeDigit = inputValue.length === 3;

        // Извлекаем степенную часть в зависимости от длины числа
        let powerPart;
        if (isThreeDigit) {
            // Для трехзначных берем первые две цифры
            powerPart = parseInt(inputValue.substring(0, 2));
        } else if (isFourDigit) {
            // Для четырехзначных берем последние две цифры
            powerPart = parseInt(inputValue.substring(2));
        } else { // Для пятизначных
            // Берем последние две цифры
            powerPart = parseInt(inputValue.substring(3));
        }

        const values = new Array(5);
        values[selectedIndex] = inputValue;

        // Заполняем значения до выбранного индекса (уменьшаем степень двойки)
        let currentPowerPart = powerPart;
        for (let i = selectedIndex - 1; i >= 0; i--) {
            currentPowerPart = Math.max(1, Math.floor(currentPowerPart / 2));
            if (isThreeDigit) {
                const powerDigits = currentPowerPart.toString().padStart(2, '0');
                // Генерируем случайную последнюю цифру
                const randomLastDigit = Math.floor(1 + Math.random() * 9);
                values[i] = `${powerDigits}${randomLastDigit}`;
            } else if (isFourDigit) {
                // Генерируем случайные первые две цифры
                const randomFirstPart = Math.floor(10 + Math.random() * 90);
                const powerDigits = currentPowerPart.toString().padStart(2, '0');
                values[i] = `${randomFirstPart}${powerDigits}`;
            } else {
                // Для пятизначных
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                const randomMiddlePart = Math.floor(10 + Math.random() * 90);
                const powerDigits = currentPowerPart.toString().padStart(2, '0');
                values[i] = `${randomFirstDigit}${randomMiddlePart}${powerDigits}`;
            }
        }

        // Заполняем значения после выбранного индекса (увеличиваем степень двойки)
        currentPowerPart = powerPart;
        for (let i = selectedIndex + 1; i < 5; i++) {
            currentPowerPart = Math.min(64, currentPowerPart * 2);
            if (isThreeDigit) {
                const powerDigits = currentPowerPart.toString().padStart(2, '0');
                const randomLastDigit = Math.floor(1 + Math.random() * 9);
                values[i] = `${powerDigits}${randomLastDigit}`;
            } else if (isFourDigit) {
                // Генерируем случайные первые две цифры
                const randomFirstPart = Math.floor(10 + Math.random() * 90);
                const powerDigits = currentPowerPart.toString().padStart(2, '0');
                values[i] = `${randomFirstPart}${powerDigits}`;
            } else {
                // Для пятизначных
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                const randomMiddlePart = Math.floor(10 + Math.random() * 90);
                const powerDigits = currentPowerPart.toString().padStart(2, '0');
                values[i] = `${randomFirstDigit}${randomMiddlePart}${powerDigits}`;
            }
        }

        const numericValues = values.map(v => parseInt(v, 10)); // Преобразуем в массив чисел
        const sum = numericValues.reduce((a, b) => a + b, 0); // Суммируем числа
        let T = sum + 1;
        function factorize(n) {
        let factors = [];
        // Ищем простые делители числа n
        for (let i = 2; i <= Math.sqrt(n); i++) {
            while (n % i === 0) {
                factors.push(i); // Добавляем делитель в массив
                n /= i; // Делим на этот делитель
            }
        }
        // Если остался простое число больше 1
        if (n > 1) {
            factors.push(n);
        }
        return factors;
    }
    
        // Разложение T + 1 на два простых числа
        const [prime1, prime2] = factorize(T);
        if (!prime1 || !prime2) {
            throw new Error('Невозможно разложить T + 1 на два простых числа');
        }

        // Используем найденные простые числа для R и S
        let R = prime1;
        let S = prime2;

        // Если R >= S, меняем их местами
        if (R >= S) {
            [R, S] = [S, R];
        }
        R = findDynamicR(T); // Пересчитываем R, если нужно

        // Функция для нахождения наибольшего общего делителя
        function gcd(a, b) {
            while (b) {
                [a, b] = [b, a % b];
            }
            return a;
        }
        // Функция для нахождения R, которое взаимно простое с T
        function findDynamicR(T) {
            let R = 2; // Начинаем с первого возможного R
            while (gcd(R, T) !== 1) {  // Пока НОД не равен 1
                R++;
            }
            return R;
        }

        // Расширенный алгоритм Евклида для нахождения обратного элемента
        function extendedEuclidean(a, b) {
            if (b === 0) {
                return [1, 0, a];
            }
            const [x1, y1, gcd] = extendedEuclidean(b, a % b);
            const x = y1;
            const y = x1 - Math.floor(a / b) * y1;
            return [x, y, gcd];
        }

        // Находим мультипликативную инверсию для S
        const [S_inv, , gcdResult] = extendedEuclidean(R, T);
        if (gcdResult !== 1) {
            throw new Error('Невозможно найти мультипликативную инверсию');
        }

        // Корректируем значение S_inv
        const adjustedS = (S_inv % T + T) % T; // Модифицируем S_inv для положительного значения

        // Массив bValues, вычисленный с использованием R и T
        const bValues = numericValues.map(a => (a * R) % T);
        let steps = `Сгенерированные значения a:\n`;
        values.forEach((a, i) => {
            steps += `a${i} = ${a}${i === selectedIndex ? ' (введено)' : ''}\n`;
        });
        steps += `\n1) Найдём R, S, T:\n`;
        steps += `Σai = ${numericValues.join(' + ')} = ${sum}\n`;
        steps += `Пусть T = ${T} > Σai = ${sum}\n`;
        steps += `Пусть R = ${R} < T = ${T}\n`;
        steps += `Найдём S: RS ≡ 1 (mod T)\n`;
        steps += `S = ${adjustedS}\n\n`;

        steps += `2) Составим вектор b = a·R mod T:\n`;
        bValues.forEach((b, i) => {
            steps += `b${i} = ${numericValues[i]}·${R} mod ${T} = ${b}\n`;
        });
        steps += `\nSecret key = (S = ${adjustedS}, T = ${T})\n`;
        steps += `Public key = b\n`;

        steps += `\n3) Зашифруем сообщение M:\n`;

        let M = '';
        if (backupM.length === 5 && /^[01]{5}$/.test(backupM)) {
            M = backupM;
        } else {
            for (let i = 0; i < 5; i++) {
                M += Math.round(Math.random());
            }
        }

        let C2 = 0;
        for (let i = 0; i < 5; i++) {
            if (M[i] === '1') {
                C2 += bValues[i];
            }
        }

        steps += `M = ${M.split('').reverse().join('')}\n`;
        steps += `C_2 = `;
        let firstTerm = true;
        for (let i = 0; i < 5; i++) {
            if (M[i] === '1') {
                if (!firstTerm) steps += ' + ';
                steps += `${bValues[i]}`;
                firstTerm = false;
            }
        }
        steps += ` = ${C2}\n`;

        steps += `\n4) Расшифровка: Проверяем восстановление M с C_2 и S\n`;

        let sum_ai = BigInt(C2) * BigInt(adjustedS) % BigInt(T);
        steps += `C_2·S (mod T) = ${C2}·${adjustedS} mod ${T} = ${sum_ai}\n`;

        let recovered_M = '';
        for (let i = 4; i >= 0; i--) {
            if (sum_ai >= BigInt(numericValues[i])) {
                recovered_M = '1' + recovered_M;
                sum_ai -= BigInt(numericValues[i]);
                steps += `Вычитаем a${i} = ${numericValues[i]}, остаток = ${sum_ai}\n`;
            } else {
                recovered_M = '0' + recovered_M;
                steps += `a${i} = ${numericValues[i]} не вычитается, остаток = ${sum_ai}\n`;
            }
        }

        steps += `Восстановленное M = ${recovered_M.split('').reverse().join('')}\n`;

        if (recovered_M === M) {
            steps += `Дешифрование прошло успешно!\n`;
        } else {
            steps += `Дешифрование не удалось. Попробуйте другое значение.\n`;
        }

        solution.textContent = steps;
        solution.style.display = 'block';
        error.textContent = '';
    } catch (err) {
        error.textContent = err.message;
        solution.style.display = 'none';
    }
}
 // Номер 4 начинается тут
 function calculateKnapsackFor5() {
    const selectedIndex = parseInt(document.getElementById('a-index-5').value);
    const inputValue = document.getElementById('a-value-5').value;
    const backupM = document.getElementById('backup-m-5').value.trim();
    const solution = document.getElementById('knapsack-solution-5');
    const error = document.getElementById('knapsack-error-5');

    try {
        if (isNaN(parseInt(inputValue))) {
            throw new Error('Пожалуйста, введите значение a');
        }

        if (inputValue.length < 3 || inputValue.length > 5) {
            throw new Error('Число должно быть длиной 3, 4 или 5 цифр');
        }

        const isFiveDigit = inputValue.length === 5;
        const isFourDigit = inputValue.length === 4;
        const isThreeDigit = inputValue.length === 3;

        let powerPart;
        if (isThreeDigit) {
            powerPart = parseInt(inputValue.substring(1));
        } else if (isFourDigit) {
            powerPart = parseInt(inputValue.substring(0, 2));
        } else {
            powerPart = parseInt(inputValue.substring(1, 3));
        }

        const values = new Array(5);
        values[selectedIndex] = inputValue;

        let currentPowerPart = powerPart;
        for (let i = selectedIndex - 1; i >= 0; i--) {
            currentPowerPart = Math.max(1, Math.floor(currentPowerPart / 5)); // Изменено на 5
            if (isThreeDigit) {
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                values[i] = `${randomFirstDigit}${currentPowerPart.toString().padStart(2, '0')}`;
            } else if (isFourDigit) {
                const randomPart = Math.floor(1 + Math.random() * 99).toString().padStart(2, '0');
                values[i] = `${currentPowerPart.toString().padStart(2, '0')}${randomPart}`;
            } else {
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                const randomPart = Math.floor(1 + Math.random() * 99).toString().padStart(2, '0');
                values[i] = `${randomFirstDigit}${currentPowerPart.toString().padStart(2, '0')}${randomPart}`;
            }
        }

        currentPowerPart = powerPart;
        for (let i = selectedIndex + 1; i < 5; i++) {
            currentPowerPart = Math.min(625, currentPowerPart * 5); // Изменено на 5
            if (isThreeDigit) {
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                values[i] = `${randomFirstDigit}${currentPowerPart.toString().padStart(2, '0')}`;
            } else if (isFourDigit) {
                const randomPart = Math.floor(1 + Math.random() * 99).toString().padStart(2, '0');
                values[i] = `${currentPowerPart.toString().padStart(2, '0')}${randomPart}`;
            } else {
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                const randomPart = Math.floor(1 + Math.random() * 99).toString().padStart(2, '0');
                values[i] = `${randomFirstDigit}${currentPowerPart.toString().padStart(2, '0')}${randomPart}`;
            }
        }

        const numericValues = values.map(v => parseInt(v, 10)); // Преобразуем в массив чисел
        const sum = numericValues.reduce((a, b) => a + b, 0); // Суммируем числа
        let T = sum + 1;
        function factorize(n) {
        let factors = [];
        // Ищем простые делители числа n
        for (let i = 2; i <= Math.sqrt(n); i++) {
            while (n % i === 0) {
                factors.push(i); // Добавляем делитель в массив
                n /= i; // Делим на этот делитель
            }
        }
        // Если остался простое число больше 1
        if (n > 1) {
            factors.push(n);
        }
        return factors;
    }
    
        // Разложение T + 1 на два простых числа
        const [prime1, prime2] = factorize(T);
        if (!prime1 || !prime2) {
            throw new Error('Невозможно разложить T + 1 на два простых числа');
        }

        // Используем найденные простые числа для R и S
        let R = prime1;
        let S = prime2;

        // Если R >= S, меняем их местами
        if (R >= S) {
            [R, S] = [S, R];
        }
        R = findDynamicR(T); // Пересчитываем R, если нужно

        // Функция для нахождения наибольшего общего делителя
        function gcd(a, b) {
            while (b) {
                [a, b] = [b, a % b];
            }
            return a;
        }
        // Функция для нахождения R, которое взаимно простое с T
        function findDynamicR(T) {
            let R = 2; // Начинаем с первого возможного R
            while (gcd(R, T) !== 1) {  // Пока НОД не равен 1
                R++;
            }
            return R;
        }

        // Расширенный алгоритм Евклида для нахождения обратного элемента
        function extendedEuclidean(a, b) {
            if (b === 0) {
                return [1, 0, a];
            }
            const [x1, y1, gcd] = extendedEuclidean(b, a % b);
            const x = y1;
            const y = x1 - Math.floor(a / b) * y1;
            return [x, y, gcd];
        }

        // Находим мультипликативную инверсию для S
        const [S_inv, , gcdResult] = extendedEuclidean(R, T);
        if (gcdResult !== 1) {
            throw new Error('Невозможно найти мультипликативную инверсию');
        }

        // Корректируем значение S_inv
        const adjustedS = (S_inv % T + T) % T; // Модифицируем S_inv для положительного значения

        // Массив bValues, вычисленный с использованием R и T
        const bValues = numericValues.map(a => (a * R) % T);
        let steps = `Сгенерированные значения a:\n`;
        values.forEach((a, i) => {
            steps += `a${i} = ${a}${i === selectedIndex ? ' (введено)' : ''}\n`;
        });
        steps += `\n1) Найдём R, S, T:\n`;
        steps += `Σai = ${numericValues.join(' + ')} = ${sum}\n`;
        steps += `Пусть T = ${T} > Σai = ${sum}\n`;
        steps += `Пусть R = ${R} < T = ${T}\n`;
        steps += `Найдём S: RS ≡ 1 (mod T)\n`;
        steps += `S = ${adjustedS}\n\n`;

        steps += `2) Составим вектор b = a·R mod T:\n`;
        bValues.forEach((b, i) => {
            steps += `b${i} = ${numericValues[i]}·${R} mod ${T} = ${b}\n`;
        });
        steps += `\nSecret key = (S = ${adjustedS}, T = ${T})\n`;
        steps += `Public key = b\n`;

        steps += `\n3) Зашифруем сообщение M:\n`;

        let M = '';
        for (let i = 0; i < 5; i++) {
            M += Math.round(Math.random());
        }

        let C2 = 0;
        for (let i = 0; i < 5; i++) {
            if (M[i] === '1') {
                C2 += bValues[i];
            }
        }

        steps += `M = ${M.split('').reverse().join('')}\n`;
        steps += `C_2 = `;
        let firstTerm = true;
        for (let i = 0; i < 5; i++) {
            if (M[i] === '1') {
                if (!firstTerm) steps += ' + ';
                steps += `${bValues[i]}`;
                firstTerm = false;
            }
        }
        steps += ` = ${C2}\n`;

        steps += `\n4) Расшифровка: Проверяем восстановление M с C_2 и S\n`;

        let sum_ai = BigInt(C2) * BigInt(adjustedS) % BigInt(T);
        steps += `C_2·S (mod T) = ${C2}·${adjustedS} mod ${T} = ${sum_ai}\n`;

        let recovered_M = '';
        for (let i = 4; i >= 0; i--) {
            if (sum_ai >= BigInt(numericValues[i])) {
                recovered_M = '1' + recovered_M;
                sum_ai -= BigInt(numericValues[i]);
                steps += `Вычитаем a${i} = ${numericValues[i]}, остаток = ${sum_ai}\n`;
            } else {
                recovered_M = '0' + recovered_M;
                steps += `a${i} = ${numericValues[i]} не вычитается, остаток = ${sum_ai}\n`;
            }
        }

        steps += `Восстановленное M = ${recovered_M.split('').reverse().join('')}\n`;

        if (recovered_M === M) {
            steps += `Дешифрование прошло успешно!\n`;
        } else {
            if (backupM.length === 5 && /^[01]{5}$/.test(backupM)) {
                M = backupM;
            } else {
                M = '10001';
            }

            C2 = 0;
            for (let i = 0; i < 5; i++) {
                if (M[i] === '1') {
                    C2 += bValues[i];
                }
            }

            steps += `Попробуем другое сообщение M = ${M}\n`;
            steps += `C_2 = `;
            firstTerm = true;
            for (let i = 0; i < 5; i++) {
                if (M[i] === '1') {
                    if (!firstTerm) steps += ' + ';
                    steps += `${bValues[i]}`;
                    firstTerm = false;
                }
            }
            steps += ` = ${C2}\n`;

            let newSum_ai = BigInt(C2) * BigInt(adjustedS) % BigInt(T);
            steps += `C_2·S (mod T) = ${C2}·${adjustedS} mod ${T} = ${newSum_ai}\n`;

            sum_ai = newSum_ai;
            recovered_M = '';
            for (let i = 4; i >= 0; i--) {
                if (sum_ai >= BigInt(numericValues[i])) {
                    recovered_M = '1' + recovered_M;
                    sum_ai -= BigInt(numericValues[i]);
                } else {
                    recovered_M = '0' + recovered_M;
                }
            }

            steps += `Восстановленное M = ${recovered_M}\n`;
        }

        solution.textContent = steps;
        solution.style.display = 'block';
        error.textContent = '';
    } catch (err) {
        error.textContent = err.message;
        solution.style.display = 'none';
    }
}
// Номер 4.1 начинается тут
function calculateKnapsackFor5Modified() {
    const selectedIndex = parseInt(document.getElementById('a-index-5-mod').value);
    const inputValue = document.getElementById('a-value-5-mod').value;
    const backupM = document.getElementById('backup-m-5-mod').value.trim();
    const solution = document.getElementById('knapsack-solution-5-mod');
    const error = document.getElementById('knapsack-error-5-mod');

    try {
        if (isNaN(parseInt(inputValue))) {
            throw new Error('Пожалуйста, введите значение a');
        }

        if (inputValue.length < 3 || inputValue.length > 5) {
            throw new Error('Число должно быть длиной 3, 4 или 5 цифр');
        }

        const isFiveDigit = inputValue.length === 5;
        const isFourDigit = inputValue.length === 4;
        const isThreeDigit = inputValue.length === 3;

        let powerPart;
        if (isThreeDigit) {
            // Для трёхзначных берём первые две цифры
            powerPart = parseInt(inputValue.substring(0, 2));
            
        } else if (isFourDigit) {
            // Для четырёхзначных берём последние две цифры
            powerPart = parseInt(inputValue.substring(2));
        } else {
            // Для пятизначных берём предпоследние две цифры (3-4 позиция)
            powerPart = parseInt(inputValue.substring(2, 4));
        }

        const values = new Array(5);
        values[selectedIndex] = inputValue;

        let currentPowerPart = powerPart;
        for (let i = selectedIndex - 1; i >= 0; i--) {
            currentPowerPart = Math.max(1, Math.floor(currentPowerPart / 5));
            if (isThreeDigit) {
                // Для трёхзначных: первые две цифры - степень, последняя рандомная
                const randomLastDigit = Math.floor(1 + Math.random() * 9);
                values[i] = `${currentPowerPart.toString().padStart(2, '0')}${randomLastDigit}`;
            } else if (isFourDigit) {
                // Для четырёхзначных: первые две рандомные, последние две - степень
                const randomPart = Math.floor(1 + Math.random() * 99).toString().padStart(2, '0');
                values[i] = `${randomPart}${currentPowerPart.toString().padStart(2, '0')}`;
            } else {
                // Для пятизначных: первая рандомная, следующие две рандомные, предпоследние две - степень, последняя рандомная
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                const randomFirstPart = Math.floor(1 + Math.random() * 99).toString().padStart(2, '0');
                const randomLastDigit = Math.floor(1 + Math.random() * 9);
                values[i] = `${randomFirstDigit}${randomFirstPart}${currentPowerPart.toString().padStart(2, '0')}${randomLastDigit}`;
            }
        }

        currentPowerPart = powerPart;
        for (let i = selectedIndex + 1; i < 5; i++) {
            currentPowerPart = Math.min(625, currentPowerPart * 5);
            if (isThreeDigit) {
                const randomLastDigit = Math.floor(1 + Math.random() * 9);
                values[i] = `${currentPowerPart.toString().padStart(2, '0')}${randomLastDigit}`;
            } else if (isFourDigit) {
                const randomPart = Math.floor(1 + Math.random() * 99).toString().padStart(2, '0');
                values[i] = `${randomPart}${currentPowerPart.toString().padStart(2, '0')}`;
            } else {
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                const randomFirstPart = Math.floor(1 + Math.random() * 99).toString().padStart(2, '0');
                const randomLastDigit = Math.floor(1 + Math.random() * 9);
                values[i] = `${randomFirstDigit}${randomFirstPart}${currentPowerPart.toString().padStart(2, '0')}${randomLastDigit}`;
            }
        }

        const numericValues = values.map(v => parseInt(v, 10)); // Преобразуем в массив чисел
        const sum = numericValues.reduce((a, b) => a + b, 0); // Суммируем числа
        let T = sum + 1;
        function factorize(n) {
        let factors = [];
        // Ищем простые делители числа n
        for (let i = 2; i <= Math.sqrt(n); i++) {
            while (n % i === 0) {
                factors.push(i); // Добавляем делитель в массив
                n /= i; // Делим на этот делитель
            }
        }
        // Если остался простое число больше 1
        if (n > 1) {
            factors.push(n);
        }
        return factors;
    }
    
        // Разложение T + 1 на два простых числа
        const [prime1, prime2] = factorize(T);
        if (!prime1 || !prime2) {
            throw new Error('Невозможно разложить T + 1 на два простых числа');
        }

        // Используем найденные простые числа для R и S
        let R = prime1;
        let S = prime2;

        // Если R >= S, меняем их местами
        if (R >= S) {
            [R, S] = [S, R];
        }
        R = findDynamicR(T); // Пересчитываем R, если нужно

        // Функция для нахождения наибольшего общего делителя
        function gcd(a, b) {
            while (b) {
                [a, b] = [b, a % b];
            }
            return a;
        }
        // Функция для нахождения R, которое взаимно простое с T
        function findDynamicR(T) {
            let R = 2; // Начинаем с первого возможного R
            while (gcd(R, T) !== 1) {  // Пока НОД не равен 1
                R++;
            }
            return R;
        }

        // Расширенный алгоритм Евклида для нахождения обратного элемента
        function extendedEuclidean(a, b) {
            if (b === 0) {
                return [1, 0, a];
            }
            const [x1, y1, gcd] = extendedEuclidean(b, a % b);
            const x = y1;
            const y = x1 - Math.floor(a / b) * y1;
            return [x, y, gcd];
        }

        // Находим мультипликативную инверсию для S
        const [S_inv, , gcdResult] = extendedEuclidean(R, T);
        if (gcdResult !== 1) {
            throw new Error('Невозможно найти мультипликативную инверсию');
        }

        // Корректируем значение S_inv
        const adjustedS = (S_inv % T + T) % T; // Модифицируем S_inv для положительного значения

        // Массив bValues, вычисленный с использованием R и T
        const bValues = numericValues.map(a => (a * R) % T);
        let steps = `Сгенерированные значения a:\n`;
        values.forEach((a, i) => {
            steps += `a${i} = ${a}${i === selectedIndex ? ' (введено)' : ''}\n`;
        });
        steps += `\n1) Найдём R, S, T:\n`;
        steps += `Σai = ${numericValues.join(' + ')} = ${sum}\n`;
        steps += `Пусть T = ${T} > Σai = ${sum}\n`;
        steps += `Пусть R = ${R} < T = ${T}\n`;
        steps += `Найдём S: RS ≡ 1 (mod T)\n`;
        steps += `S = ${adjustedS}\n\n`;

        steps += `2) Составим вектор b = a·R mod T:\n`;
        bValues.forEach((b, i) => {
            steps += `b${i} = ${numericValues[i]}·${R} mod ${T} = ${b}\n`;
        });
        steps += `\nSecret key = (S = ${adjustedS}, T = ${T})\n`;
        steps += `Public key = b\n`;

        steps += `\n3) Зашифруем сообщение M:\n`;

        let M = '';
        for (let i = 0; i < 5; i++) {
            M += Math.round(Math.random());
        }

        let C2 = 0;
        for (let i = 0; i < 5; i++) {
            if (M[i] === '1') {
                C2 += bValues[i];
            }
        }

        steps += `M = ${M.split('').reverse().join('')}\n`;
        steps += `C_2 = `;
        let firstTerm = true;
        for (let i = 0; i < 5; i++) {
            if (M[i] === '1') {
                if (!firstTerm) steps += ' + ';
                steps += `${bValues[i]}`;
                firstTerm = false;
            }
        }
        steps += ` = ${C2}\n`;

        steps += `\n4) Расшифровка: Проверяем восстановление M с C_2 и S\n`;

        let sum_ai = BigInt(C2) * BigInt(adjustedS) % BigInt(T);
        steps += `C_2·S (mod T) = ${C2}·${adjustedS} mod ${T} = ${sum_ai}\n`;

        let recovered_M = '';
        for (let i = 4; i >= 0; i--) {
            if (sum_ai >= BigInt(numericValues[i])) {
                recovered_M = '1' + recovered_M;
                sum_ai -= BigInt(numericValues[i]);
                steps += `Вычитаем a${i} = ${numericValues[i]}, остаток = ${sum_ai}\n`;
            } else {
                recovered_M = '0' + recovered_M;
                steps += `a${i} = ${numericValues[i]} не вычитается, остаток = ${sum_ai}\n`;
            }
        }

        steps += `Восстановленное M = ${recovered_M.split('').reverse().join('')}\n`;

        if (recovered_M !== M) {
            if (backupM.length === 5 && /^[01]{5}$/.test(backupM)) {
                M = backupM;
            } else {
                M = '10001';
            }

            C2 = 0;
            for (let i = 0; i < 5; i++) {
                if (M[i] === '1') {
                    C2 += bValues[i];
                }
            }

            steps += `Попробуем другое сообщение M = ${M}\n`;
            steps += `C_2 = `;
            firstTerm = true;
            for (let i = 0; i < 5; i++) {
                if (M[i] === '1') {
                    if (!firstTerm) steps += ' + ';
                    steps += `${bValues[i]}`;
                    firstTerm = false;
                }
            }
            steps += ` = ${C2}\n`;

            let newSum_ai = BigInt(C2) * BigInt(adjustedS) % BigInt(T);
            steps += `C_2·S (mod T) = ${C2}·${adjustedS} mod ${T} = ${newSum_ai}\n`;

            sum_ai = newSum_ai;
            recovered_M = '';
            for (let i = 4; i >= 0; i--) {
                if (sum_ai >= BigInt(numericValues[i])) {
                    recovered_M = '1' + recovered_M;
                    sum_ai -= BigInt(numericValues[i]);
                } else {
                    recovered_M = '0' + recovered_M;
                }
            }

            steps += `Восстановленное M = ${recovered_M}\n`;
        }

        solution.textContent = steps;
        solution.style.display = 'block';
        error.textContent = '';
    } catch (err) {
        error.textContent = err.message;
        solution.style.display = 'none';
    }
}
//Номер 5 начинается тут 
function calculateKnapsackFor3Lower() {
    const selectedIndex = parseInt(document.getElementById('a-index-3-lower').value);
    const inputValue = document.getElementById('a-value-3-lower').value;
    const backupM = document.getElementById('backup-m-3-lower').value.trim();
    const solution = document.getElementById('knapsack-solution-3-lower');
    const error = document.getElementById('knapsack-error-3-lower');

    try {
        if (isNaN(parseInt(inputValue))) {
            throw new Error('Пожалуйста, введите значение a');
        }

        if (inputValue.length < 3 || inputValue.length > 5) {
            throw new Error('Число должно быть длиной 3, 4 или 5 цифр');
        }

        const isFiveDigit = inputValue.length === 5;
        const isFourDigit = inputValue.length === 4;
        const isThreeDigit = inputValue.length === 3;

        let powerPart;
        if (isThreeDigit) {
            powerPart = parseInt(inputValue.substring(1));
        } else if (isFourDigit) {
            powerPart = parseInt(inputValue.substring(2));
        } else {
            powerPart = parseInt(inputValue.substring(3));
        }

        const values = new Array(5);
        values[selectedIndex] = inputValue;

        let currentPowerPart = powerPart;
        for (let i = selectedIndex - 1; i >= 0; i--) {
            currentPowerPart = Math.max(1, Math.floor(currentPowerPart / 3));
            if (isThreeDigit) {
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                values[i] = `${randomFirstDigit}${currentPowerPart.toString().padStart(2, '0')}`;
            } else if (isFourDigit) {
                const randomFirst = Math.floor(10 + Math.random() * 90);
                values[i] = `${randomFirst}${currentPowerPart.toString().padStart(2, '0')}`;
            } else {
                const randomFirst = Math.floor(10 + Math.random() * 90);
                const randomLast = Math.floor(10 + Math.random() * 90);
                values[i] = `${randomFirst}${currentPowerPart.toString().padStart(2, '0')}${randomLast}`;
            }
        }

        currentPowerPart = powerPart;
        for (let i = selectedIndex + 1; i < 5; i++) {
            currentPowerPart = Math.min(81, currentPowerPart * 3);
            if (isThreeDigit) {
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                values[i] = `${randomFirstDigit}${currentPowerPart.toString().padStart(2, '0')}`;
            } else if (isFourDigit) {
                const randomFirst = Math.floor(10 + Math.random() * 90);
                values[i] = `${randomFirst}${currentPowerPart.toString().padStart(2, '0')}`;
            } else {
                const randomFirst = Math.floor(10 + Math.random() * 90);
                const randomLast = Math.floor(10 + Math.random() * 90);
                values[i] = `${randomFirst}${currentPowerPart.toString().padStart(2, '0')}${randomLast}`;
            }
        }

        // Rest of the knapsack calculation remains the same
        const numericValues = values.map(v => parseInt(v, 10)); // Преобразуем в массив чисел
        const sum = numericValues.reduce((a, b) => a + b, 0); // Суммируем числа
        let T = sum + 1;
        function factorize(n) {
        let factors = [];
        // Ищем простые делители числа n
        for (let i = 2; i <= Math.sqrt(n); i++) {
            while (n % i === 0) {
                factors.push(i); // Добавляем делитель в массив
                n /= i; // Делим на этот делитель
            }
        }
        // Если остался простое число больше 1
        if (n > 1) {
            factors.push(n);
        }
        return factors;
    }
    
        // Разложение T + 1 на два простых числа
        const [prime1, prime2] = factorize(T);
        if (!prime1 || !prime2) {
            throw new Error('Невозможно разложить T + 1 на два простых числа');
        }

        // Используем найденные простые числа для R и S
        let R = prime1;
        let S = prime2;

        // Если R >= S, меняем их местами
        if (R >= S) {
            [R, S] = [S, R];
        }
        R = findDynamicR(T); // Пересчитываем R, если нужно

        // Функция для нахождения наибольшего общего делителя
        function gcd(a, b) {
            while (b) {
                [a, b] = [b, a % b];
            }
            return a;
        }
        // Функция для нахождения R, которое взаимно простое с T
        function findDynamicR(T) {
            let R = 2; // Начинаем с первого возможного R
            while (gcd(R, T) !== 1) {  // Пока НОД не равен 1
                R++;
            }
            return R;
        }

        // Расширенный алгоритм Евклида для нахождения обратного элемента
        function extendedEuclidean(a, b) {
            if (b === 0) {
                return [1, 0, a];
            }
            const [x1, y1, gcd] = extendedEuclidean(b, a % b);
            const x = y1;
            const y = x1 - Math.floor(a / b) * y1;
            return [x, y, gcd];
        }

        // Находим мультипликативную инверсию для S
        const [S_inv, , gcdResult] = extendedEuclidean(R, T);
        if (gcdResult !== 1) {
            throw new Error('Невозможно найти мультипликативную инверсию');
        }

        // Корректируем значение S_inv
        const adjustedS = (S_inv % T + T) % T; // Модифицируем S_inv для положительного значения

        // Массив bValues, вычисленный с использованием R и T
        const bValues = numericValues.map(a => (a * R) % T);
        let steps = `Сгенерированные значения a:\n`;
        values.forEach((a, i) => {
            steps += `a${i} = ${a}${i === selectedIndex ? ' (введено)' : ''}\n`;
        });
        
        steps += `\n1) Найдём R, S, T:\n`;
        steps += `Σai = ${numericValues.join(' + ')} = ${sum}\n`;
        steps += `Пусть T = ${T} > Σai = ${sum}\n`;
        steps += `Пусть R = ${R} < T = ${T}\n`;
        steps += `Найдём S: RS ≡ 1 (mod T)\n`;
        steps += `S = ${adjustedS}\n\n`;

        steps += `2) Составим вектор b = a·R mod T:\n`;
        bValues.forEach((b, i) => {
            steps += `b${i} = ${numericValues[i]}·${R} mod ${T} = ${b}\n`;
        });
        steps += `\nSecret key = (S = ${adjustedS}, T = ${T})\n`;
        steps += `Public key = b\n`;

        steps += `\n3) Зашифруем сообщение M:\n`;

        let M = '';
        for (let i = 0; i < 5; i++) {
            M += Math.round(Math.random());
        }

        let C2 = 0;
        for (let i = 0; i < 5; i++) {
            if (M[i] === '1') {
                C2 += bValues[i];
            }
        }

        steps += `M = ${M.split('').reverse().join('')}\n`;
        steps += `C_2 = `;
        let firstTerm = true;
        for (let i = 0; i < 5; i++) {
            if (M[i] === '1') {
                if (!firstTerm) steps += ' + ';
                steps += `${bValues[i]}`;
                firstTerm = false;
            }
        }
        steps += ` = ${C2}\n`;

        steps += `\n4) Расшифровка: Проверяем восстановление M с C_2 и S\n`;

        let sum_ai = BigInt(C2) * BigInt(adjustedS) % BigInt(T);
        steps += `C_2·S (mod T) = ${C2}·${adjustedS} mod ${T} = ${sum_ai}\n`;

        let recovered_M = '';
        for (let i = 4; i >= 0; i--) {
            if (sum_ai >= BigInt(numericValues[i])) {
                recovered_M = '1' + recovered_M;
                sum_ai -= BigInt(numericValues[i]);
                steps += `Вычитаем a${i} = ${numericValues[i]}, остаток = ${sum_ai}\n`;
            } else {
                recovered_M = '0' + recovered_M;
                steps += `a${i} = ${numericValues[i]} не вычитается, остаток = ${sum_ai}\n`;
            }
        }

        steps += `Восстановленное M = ${recovered_M.split('').reverse().join('')}\n`;

        if (recovered_M !== M) {
            if (backupM.length === 5 && /^[01]{5}$/.test(backupM)) {
                M = backupM;
            } else {
                M = '10001';
            }

            C2 = 0;
            for (let i = 0; i < 5; i++) {
                if (M[i] === '1') {
                    C2 += bValues[i];
                }
            }

            steps += `Попробуем другое сообщение M = ${M}\n`;
            steps += `C_2 = `;
            firstTerm = true;
            for (let i = 0; i < 5; i++) {
                if (M[i] === '1') {
                    if (!firstTerm) steps += ' + ';
                    steps += `${bValues[i]}`;
                    firstTerm = false;
                }
            }
            steps += ` = ${C2}\n`;

            let newSum_ai = BigInt(C2) * BigInt(adjustedS) % BigInt(T);
            steps += `C_2·S (mod T) = ${C2}·${adjustedS} mod ${T} = ${newSum_ai}\n`;

            sum_ai = newSum_ai;
            recovered_M = '';
            for (let i = 4; i >= 0; i--) {
                if (sum_ai >= BigInt(numericValues[i])) {
                    recovered_M = '1' + recovered_M;
                    sum_ai -= BigInt(numericValues[i]);
                } else {
                    recovered_M = '0' + recovered_M;
                }
            }

            steps += `Восстановленное M = ${recovered_M}\n`;
        }

        solution.textContent = steps;
        solution.style.display = 'block';
        error.textContent = '';
    } catch (err) {
        error.textContent = err.message;
        solution.style.display = 'none';
    }
}
//Номер 5.1 начинается тут
function calculateKnapsackFor3Upper() {
    const selectedIndex = parseInt(document.getElementById('a-index-3-upper').value);
    const inputValue = document.getElementById('a-value-3-upper').value;
    const backupM = document.getElementById('backup-m-3-upper').value.trim();
    const solution = document.getElementById('knapsack-solution-3-upper');
    const error = document.getElementById('knapsack-error-3-upper');

    try {
        if (isNaN(parseInt(inputValue))) {
            throw new Error('Пожалуйста, введите значение a');
        }

        if (inputValue.length < 3 || inputValue.length > 5) {
            throw new Error('Число должно быть длиной 3, 4 или 5 цифр');
        }

        const isFiveDigit = inputValue.length === 5;
        const isFourDigit = inputValue.length === 4;
        const isThreeDigit = inputValue.length === 3;

        let powerPart;
        if (isThreeDigit) {
            powerPart = parseInt(inputValue.substring(0, 1));
        } else if (isFourDigit) {
            powerPart = parseInt(inputValue.substring(0, 2));
        } else {
            powerPart = parseInt(inputValue.substring(1, 3));
        }

        const values = new Array(5);
        values[selectedIndex] = inputValue;

        let currentPowerPart = powerPart;
        for (let i = selectedIndex - 1; i >= 0; i--) {
            currentPowerPart = Math.max(1, Math.floor(currentPowerPart / 3));
            if (isThreeDigit) {
                const randomLastDigits = Math.floor(10 + Math.random() * 90);
                values[i] = `${currentPowerPart}${randomLastDigits}`;
            } else if (isFourDigit) {
                const randomLastDigits = Math.floor(10 + Math.random() * 90);
                values[i] = `${currentPowerPart.toString().padStart(2, '0')}${randomLastDigits}`;
            } else {
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                const randomLastDigits = Math.floor(10 + Math.random() * 90);
                values[i] = `${randomFirstDigit}${currentPowerPart.toString().padStart(2, '0')}${randomLastDigits}`;
            }
        }

        currentPowerPart = powerPart;
        for (let i = selectedIndex + 1; i < 5; i++) {
            currentPowerPart = Math.min(81, currentPowerPart * 3);
            if (isThreeDigit) {
                const randomLastDigits = Math.floor(10 + Math.random() * 90);
                values[i] = `${currentPowerPart}${randomLastDigits}`;
            } else if (isFourDigit) {
                const randomLastDigits = Math.floor(10 + Math.random() * 90);
                values[i] = `${currentPowerPart.toString().padStart(2, '0')}${randomLastDigits}`;
            } else {
                const randomFirstDigit = Math.floor(1 + Math.random() * 9);
                const randomLastDigits = Math.floor(10 + Math.random() * 90);
                values[i] = `${randomFirstDigit}${currentPowerPart.toString().padStart(2, '0')}${randomLastDigits}`;
            }
        }

        // Rest of the knapsack calculation remains the same
        const numericValues = values.map(v => parseInt(v, 10)); // Преобразуем в массив чисел
        const sum = numericValues.reduce((a, b) => a + b, 0); // Суммируем числа
        let T = sum + 1;
        function factorize(n) {
        let factors = [];
        // Ищем простые делители числа n
        for (let i = 2; i <= Math.sqrt(n); i++) {
            while (n % i === 0) {
                factors.push(i); // Добавляем делитель в массив
                n /= i; // Делим на этот делитель
            }
        }
        // Если остался простое число больше 1
        if (n > 1) {
            factors.push(n);
        }
        return factors;
    }
    
        // Разложение T + 1 на два простых числа
        const [prime1, prime2] = factorize(T);
        if (!prime1 || !prime2) {
            throw new Error('Невозможно разложить T + 1 на два простых числа');
        }

        // Используем найденные простые числа для R и S
        let R = prime1;
        let S = prime2;

        // Если R >= S, меняем их местами
        if (R >= S) {
            [R, S] = [S, R];
        }
        R = findDynamicR(T); // Пересчитываем R, если нужно

        // Функция для нахождения наибольшего общего делителя
        function gcd(a, b) {
            while (b) {
                [a, b] = [b, a % b];
            }
            return a;
        }
        // Функция для нахождения R, которое взаимно простое с T
        function findDynamicR(T) {
            let R = 2; // Начинаем с первого возможного R
            while (gcd(R, T) !== 1) {  // Пока НОД не равен 1
                R++;
            }
            return R;
        }

        // Расширенный алгоритм Евклида для нахождения обратного элемента
        function extendedEuclidean(a, b) {
            if (b === 0) {
                return [1, 0, a];
            }
            const [x1, y1, gcd] = extendedEuclidean(b, a % b);
            const x = y1;
            const y = x1 - Math.floor(a / b) * y1;
            return [x, y, gcd];
        }

        // Находим мультипликативную инверсию для S
        const [S_inv, , gcdResult] = extendedEuclidean(R, T);
        if (gcdResult !== 1) {
            throw new Error('Невозможно найти мультипликативную инверсию');
        }

        // Корректируем значение S_inv
        const adjustedS = (S_inv % T + T) % T; // Модифицируем S_inv для положительного значения

        // Массив bValues, вычисленный с использованием R и T
        const bValues = numericValues.map(a => (a * R) % T);
        let steps = `Сгенерированные значения a:\n`;
        values.forEach((a, i) => {
            steps += `a${i} = ${a}${i === selectedIndex ? ' (введено)' : ''}\n`;
        });
        
        steps += `\n1) Найдём R, S, T:\n`;
        steps += `Σai = ${numericValues.join(' + ')} = ${sum}\n`;
        steps += `Пусть T = ${T} > Σai = ${sum}\n`;
        steps += `Пусть R = ${R} < T = ${T}\n`;
        steps += `Найдём S: RS ≡ 1 (mod T)\n`;
        steps += `S = ${adjustedS}\n\n`;

        steps += `2) Составим вектор b = a·R mod T:\n`;
        bValues.forEach((b, i) => {
            steps += `b${i} = ${numericValues[i]}·${R} mod ${T} = ${b}\n`;
        });
        steps += `\nSecret key = (S = ${adjustedS}, T = ${T})\n`;
        steps += `Public key = b\n`;

        steps += `\n3) Зашифруем сообщение M:\n`;

        let M = '';
        for (let i = 0; i < 5; i++) {
            M += Math.round(Math.random());
        }

        let C2 = 0;
        for (let i = 0; i < 5; i++) {
            if (M[i] === '1') {
                C2 += bValues[i];
            }
        }

        steps += `M = ${M.split('').reverse().join('')}\n`;
        steps += `C_2 = `;
        let firstTerm = true;
        for (let i = 0; i < 5; i++) {
            if (M[i] === '1') {
                if (!firstTerm) steps += ' + ';
                steps += `${bValues[i]}`;
                firstTerm = false;
            }
        }
        steps += ` = ${C2}\n`;

        steps += `\n4) Расшифровка: Проверяем восстановление M с C_2 и S\n`;

        let sum_ai = BigInt(C2) * BigInt(adjustedS) % BigInt(T);
        steps += `C_2·S (mod T) = ${C2}·${adjustedS} mod ${T} = ${sum_ai}\n`;

        let recovered_M = '';
        for (let i = 4; i >= 0; i--) {
            if (sum_ai >= BigInt(numericValues[i])) {
                recovered_M = '1' + recovered_M;
                sum_ai -= BigInt(numericValues[i]);
                steps += `Вычитаем a${i} = ${numericValues[i]}, остаток = ${sum_ai}\n`;
            } else {
                recovered_M = '0' + recovered_M;
                steps += `a${i} = ${numericValues[i]} не вычитается, остаток = ${sum_ai}\n`;
            }
        }

        steps += `Восстановленное M = ${recovered_M.split('').reverse().join('')}\n`;

        if (recovered_M !== M) {
            if (backupM.length === 5 && /^[01]{5}$/.test(backupM)) {
                M = backupM;
            } else {
                M = '10001';
            }

            C2 = 0;
            for (let i = 0; i < 5; i++) {
                if (M[i] === '1') {
                    C2 += bValues[i];
                }
            }

            steps += `Попробуем другое сообщение M = ${M}\n`;
            steps += `C_2 = `;
            firstTerm = true;
            for (let i = 0; i < 5; i++) {
                if (M[i] === '1') {
                    if (!firstTerm) steps += ' + ';
                    steps += `${bValues[i]}`;
                    firstTerm = false;
                }
            }
            steps += ` = ${C2}\n`;

            let newSum_ai = BigInt(C2) * BigInt(adjustedS) % BigInt(T);
            steps += `C_2·S (mod T) = ${C2}·${adjustedS} mod ${T} = ${newSum_ai}\n`;

            sum_ai = newSum_ai;
            recovered_M = '';
            for (let i = 4; i >= 0; i--) {
                if (sum_ai >= BigInt(numericValues[i])) {
                    recovered_M = '1' + recovered_M;
                    sum_ai -= BigInt(numericValues[i]);
                } else {
                    recovered_M = '0' + recovered_M;
                }
            }

            steps += `Восстановленное M = ${recovered_M}\n`;
        }

        solution.textContent = steps;
        solution.style.display = 'block';
        error.textContent = '';

    } catch (err) {
        error.textContent = err.message;
        solution.style.display = 'none';
    }
} 
 // Номер 6 ачинается тут
 // Основная функция демонстрации работы RSA криптосистемы
 function generateRSAExample() {
    const rsaResult = document.getElementById('rsa-result');
    rsaResult.innerHTML = 'Генерация примера...';

    try {
        // Используем небольшие простые числа
        const primes = [11, 13, 17, 19, 23, 29, 31, 37];
        const [p, q, r] = selectDistinctPrimes(primes, 3);

        // Вычисляем модуль N и функцию Эйлера
        const N = p * q * r;
        const phi = (p - 1) * (q - 1) * (r - 1);

        // Генерируем пары ключей для обоих пользователей
        const keys = generateDistinctKeyPairs(phi);

        // Тестовое сообщение
        const message = 7;

        // Шифрование и расшифрование
        const encrypted = modExp(message, keys.user2.e, N);
        const decrypted = modExp(encrypted, keys.user2.d, N);

        let result = `
        <h3>Демонстрация работы криптосистемы RSA</h3>
        
        <p><strong>1. Параметры системы:</strong></p>
        <ul>
            <li>p = ${p} (простое число)</li>
            <li>q = ${q} (простое число)</li>
            <li>r = ${r} (простое число)</li>
            <li>N = p⋅q⋅r = ${N} (модуль системы)</li>
            <li>φ(N) = (p-1)(q-1)(r-1) = ${phi} (функция Эйлера)</li>
        </ul>

        <p><strong>2. Ключи пользователей:</strong></p>
        <p>Пользователь 1:</p>
        <ul>
            <li>Открытый ключ e₁ = ${keys.user1.e}</li>
            <li>Закрытый ключ d₁ = ${keys.user1.d}</li>
            <li>Проверка: ${keys.user1.e}⋅${keys.user1.d} ≡ 1 (mod ${phi})</li>
        </ul>
        
        <p>Пользователь 2:</p>
        <ul>
            <li>Открытый ключ e₂ = ${keys.user2.e}</li>
            <li>Закрытый ключ d₂ = ${keys.user2.d}</li>
            <li>Проверка: ${keys.user2.e}⋅${keys.user2.d} ≡ 1 (mod ${phi})</li>
        </ul>

        <p><strong>3. Пример обмена сообщением:</strong></p>
        <ul>
            <li>Исходное сообщение M = ${message}</li>
            <li>Шифрование (C = M^(e₂) mod N) = ${encrypted}</li>
            <li>Расшифрование (M = C^(d₂) mod N) = ${decrypted}</li>
        </ul>
        `;

        rsaResult.innerHTML = result;
    } catch (error) {
        console.error("Ошибка в генерации RSA:", error);
        rsaResult.innerHTML = `Ошибка генерации RSA: ${error.message}. Пожалуйста, попробуйте еще раз.`;
    }
}

// Функция выбора случайных различных простых чисел
function selectDistinctPrimes(primes, count) {
    const shuffled = [...primes].sort(() => Math.random() - 0.5);
    return shuffled.slice(0, count);
}

// Функция генерации различных пар ключей
function generateDistinctKeyPairs(phi) {
    // Расширенный список возможных открытых ключей
    const possibleEs = [3, 5, 7, 11, 13, 17, 19, 23];
    let user1 = null;
    let user2 = null;

    // Генерация первой пары ключей
    for (const e1 of possibleEs) {
        if (gcd(e1, phi) === 1) {
            const d1 = calculateModInverse(e1, phi);
            if (d1 !== null) {
                user1 = { e: e1, d: d1 };
                break;
            }
        }
    }

    if (!user1) throw new Error("Не удалось сгенерировать первую пару ключей");

    // Генерация второй пары ключей (отличной от первой)
    for (const e2 of possibleEs) {
        if (e2 !== user1.e && gcd(e2, phi) === 1) {
            const d2 = calculateModInverse(e2, phi);
            if (d2 !== null) {
                user2 = { e: e2, d: d2 };
                break;
            }
        }
    }

    if (!user2) throw new Error("Не удалось сгенерировать вторую пару ключей");

    return { user1, user2 };
}

// Функция вычисления НОД
function gcd(a, b) {
    a = Math.abs(a);
    b = Math.abs(b);
    while (b !== 0) {
        const temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

// Функция вычисления модульного обратного
function calculateModInverse(a, m) {
    a = ((a % m) + m) % m;
    for (let x = 1; x < m; x++) {
        if ((a * x) % m === 1) {
            return x;
        }
    }
    return null;
}

// Функция возведения в степень по модулю
function modExp(base, exp, mod) {
    if (mod === 1) return 0;
    let result = 1;
    base = base % mod;
    while (exp > 0) {
        if (exp % 2 === 1) {
            result = (result * base) % mod;
        }
        base = (base * base) % mod;
        exp = Math.floor(exp / 2);
    }
    return result;
}
    </script>
    
</body>
</html>